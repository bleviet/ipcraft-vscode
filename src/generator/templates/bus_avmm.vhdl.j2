{# VHDL Avalon-MM Bus Wrapper Template #}
{# Generates Avalon-MM slave interface with register decoding #}
--------------------------------------------------------------------------------
-- Entity: {{ entity_name }}_avmm
-- Description: Avalon-MM slave interface for register access
-- Generated by ipcore_lib VHDL Generator
--
-- Register Map:
{% for reg in registers %}
--   {{ "0x%04X" | format(loop.index0 * reg_width) }} : {{ reg.name }} ({{ reg.access }})
{% endfor %}
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.{{ entity_name }}_pkg.all;

entity {{ entity_name }}_avmm is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

{% if bus_ports %}
    -- Avalon-MM Slave Interface
{% for port in bus_ports %}
    {{ "%-16s"|format(port.name) }} : {{ "%-3s"|format(port.direction) }} {{ port.type }}{{ ";" if not loop.last else "" }}
{% endfor %}
    ;
{% endif %}

    -- Register interface
    regs_out : out t_regs_sw2hw;  -- To core (SW-writable)
    regs_in  : in  t_regs_hw2sw   -- From core (HW-writable)
  );
end entity {{ entity_name }}_avmm;

architecture rtl of {{ entity_name }}_avmm is

  -- Bus Internal Signals
  signal address       : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal read          : std_logic;
  signal write         : std_logic;
  signal writedata     : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal byteenable    : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
  signal readdata      : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal readdatavalid : std_logic;
  signal waitrequest   : std_logic;

begin

  ----------------------------------------------------------------------------
  -- Bus Interface Connections
  ----------------------------------------------------------------------------
{#- Input mapping -#}
{%- set address_port = (bus_ports | selectattr('logical_name', 'equalto', 'address') | list) %}
{%- set read_port = (bus_ports | selectattr('logical_name', 'equalto', 'read') | list) %}
{%- set write_port = (bus_ports | selectattr('logical_name', 'equalto', 'write') | list) %}
{%- set writedata_port = (bus_ports | selectattr('logical_name', 'equalto', 'writedata') | list) %}
{%- set byteenable_port = (bus_ports | selectattr('logical_name', 'equalto', 'byteenable') | list) %}

  address   <= {{ address_port[0].name if address_port else "(others => '0')" }};
  read      <= {{ read_port[0].name if read_port else "'0'" }};
  write     <= {{ write_port[0].name if write_port else "'0'" }};
  writedata <= {{ writedata_port[0].name if writedata_port else "(others => '0')" }};

{%- if byteenable_port %}
  byteenable <= {{ byteenable_port[0].name }};
{%- else %}
  byteenable <= (others => '1');
{%- endif %}

{#- Output mapping -#}
{%- set readdata_port = (bus_ports | selectattr('logical_name', 'equalto', 'readdata') | list) %}
{%- set readdatavalid_port = (bus_ports | selectattr('logical_name', 'equalto', 'readdatavalid') | list) %}
{%- set waitrequest_port = (bus_ports | selectattr('logical_name', 'equalto', 'waitrequest') | list) %}

{%- if readdata_port %}
  {{ readdata_port[0].name }} <= readdata;
{%- endif %}

{%- if readdatavalid_port %}
  {{ readdatavalid_port[0].name }} <= readdatavalid;
{%- endif %}

{%- if waitrequest_port %}
  {{ waitrequest_port[0].name }} <= waitrequest;
{%- endif %}

  ----------------------------------------------------------------------------
  -- Bus Logic
  ----------------------------------------------------------------------------

  -- No wait states
  waitrequest <= '0';

  ----------------------------------------------------------------------------
  -- Register Bank Instantiation
  ----------------------------------------------------------------------------
  u_regs : entity work.{{ entity_name }}_regs
    port map (
      clk      => clk,
      rst      => rst,
      wr_en    => write,
      wr_addr  => address,
      wr_data  => writedata,
      wr_strb  => byteenable,
      rd_en    => read,
      rd_addr  => address,
      rd_data  => readdata,
      rd_valid => readdatavalid,
      regs_out => regs_out,
      regs_in  => regs_in
    );

end architecture rtl;
