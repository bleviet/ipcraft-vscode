{# VHDL Package Template for IP Core #}
{# Generates register types, enumerations, and conversion functions #}
--------------------------------------------------------------------------------
-- Package: {{ entity_name }}_pkg
-- Generated by ipcore_lib VHDL Generator
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package {{ entity_name }}_pkg is

  ----------------------------------------------------------------------------
  -- Constants
  ----------------------------------------------------------------------------
  constant C_DATA_WIDTH : natural := {{ data_width | default(32) }};
  constant C_ADDR_WIDTH : natural := {{ addr_width | default(8) }};
  constant C_REG_WIDTH  : natural := {{ reg_width | default(4) }};  -- Bytes per register

{% if registers %}
  ----------------------------------------------------------------------------
  -- Register Enumeration (Order defines address)
  ----------------------------------------------------------------------------
  type t_reg_id is (
{% for reg in registers %}
    REG_{{ reg.name | upper }}{{ "," if not loop.last else "" }}  -- addr {{ "0x%02X" | format(loop.index0 * reg_width | default(4)) }}
{% endfor %}
  );

  -- Calculate register address from enumeration
  function reg_addr(reg : t_reg_id) return natural;
{% endif %}

  ----------------------------------------------------------------------------
  -- Register Record Types
  ----------------------------------------------------------------------------
{% for reg in registers %}
{% if reg.fields %}

  -- {{ reg.name }} register fields
  type t_reg_{{ reg.name | lower }} is record
{% for field in reg.fields %}
{% if field.width == 1 %}
    {{ field.name | lower }} : std_logic;  -- bit {{ field.offset }}
{% else %}
    {{ field.name | lower }} : std_logic_vector({{ field.width - 1 }} downto 0);  -- bits {{ field.offset + field.width - 1 }}:{{ field.offset }}
{% endif %}
{% endfor %}
  end record;

  constant C_REG_{{ reg.name | upper }}_RESET : t_reg_{{ reg.name | lower }} := (
{% for field in reg.fields %}
{% if field.width == 1 %}
    {{ field.name | lower }} => '{{ field.reset_value | default(0) }}'{{ "," if not loop.last else "" }}
{% else %}
    {{ field.name | lower }} => {{ "(others => '0')" if not field.reset_value else "std_logic_vector(to_unsigned(" ~ field.reset_value ~ ", " ~ field.width ~ "))" }}{{ "," if not loop.last else "" }}
{% endif %}
{% endfor %}
  );

  function to_slv(reg : t_reg_{{ reg.name | lower }}) return std_logic_vector;
  function to_{{ reg.name | lower }}(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_{{ reg.name | lower }};
{% endif %}
{% endfor %}

{% if registers %}
  ----------------------------------------------------------------------------
  -- Aggregate Register Records (for clean port interface)
  ----------------------------------------------------------------------------
{% set sw2hw_regs = registers | selectattr('access', 'in', ['read-write', 'write-only', 'rw', 'wo']) | list %}
{% set hw2sw_regs = registers | selectattr('access', 'in', ['read-only', 'ro']) | list %}
{% if sw2hw_regs %}

  -- SW -> HW: Registers written by software, read by hardware
  type t_regs_sw2hw is record
{% for reg in sw2hw_regs %}
    {{ reg.name | lower }} : t_reg_{{ reg.name | lower }};
{% endfor %}
  end record;

  constant C_REGS_SW2HW_RESET : t_regs_sw2hw := (
{% for reg in sw2hw_regs %}
    {{ reg.name | lower }} => C_REG_{{ reg.name | upper }}_RESET{{ "," if not loop.last else "" }}
{% endfor %}
  );
{% endif %}
{% if hw2sw_regs %}

  -- HW -> SW: Registers written by hardware, read by software
  type t_regs_hw2sw is record
{% for reg in hw2sw_regs %}
    {{ reg.name | lower }} : t_reg_{{ reg.name | lower }};
{% endfor %}
  end record;

  constant C_REGS_HW2SW_RESET : t_regs_hw2sw := (
{% for reg in hw2sw_regs %}
    {{ reg.name | lower }} => C_REG_{{ reg.name | upper }}_RESET{{ "," if not loop.last else "" }}
{% endfor %}
  );
{% endif %}
{% endif %}

end package {{ entity_name }}_pkg;


package body {{ entity_name }}_pkg is

{% if registers %}
  ----------------------------------------------------------------------------
  -- Register Address Function
  ----------------------------------------------------------------------------
  function reg_addr(reg : t_reg_id) return natural is
  begin
    return t_reg_id'pos(reg) * C_REG_WIDTH;
  end function;
{% endif %}

  ----------------------------------------------------------------------------
  -- Conversion Functions
  ----------------------------------------------------------------------------
{% for reg in registers %}
{% if reg.fields %}

  -- {{ reg.name }} conversions
  function to_slv(reg : t_reg_{{ reg.name | lower }}) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
{% for field in reg.fields %}
{% if field.width == 1 %}
    slv({{ field.offset }}) := reg.{{ field.name | lower }};
{% else %}
    slv({{ field.offset + field.width - 1 }} downto {{ field.offset }}) := reg.{{ field.name | lower }};
{% endif %}
{% endfor %}
    return slv;
  end function;

  function to_{{ reg.name | lower }}(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_{{ reg.name | lower }} is
    variable reg : t_reg_{{ reg.name | lower }};
  begin
{% for field in reg.fields %}
{% if field.width == 1 %}
    reg.{{ field.name | lower }} := slv({{ field.offset }});
{% else %}
    reg.{{ field.name | lower }} := slv({{ field.offset + field.width - 1 }} downto {{ field.offset }});
{% endif %}
{% endfor %}
    return reg;
  end function;
{% endif %}
{% endfor %}

end package body {{ entity_name }}_pkg;
