{# VHDL Standalone Register Bank Template #}
{# Generates a reusable register bank module without bus interface #}
{# Can be instantiated with any bus wrapper #}
--------------------------------------------------------------------------------
-- Entity: {{ entity_name }}_regs
-- Description: Register bank with software/hardware access interface
-- Generated by ipcore_lib VHDL Generator
--
-- This is a bus-agnostic register bank that provides:
-- - Register storage for SW-writable registers
-- - Pulse generation for write-1-to-clear fields
-- - Clean interface for hardware logic access
--
-- Connect to a bus wrapper (AXI-Lite, Avalon-MM, etc.) for host access.
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.{{ entity_name }}_pkg.all;

entity {{ entity_name }}_regs is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

    -- Write interface (from bus wrapper)
    wr_en   : in  std_logic;
    wr_addr : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    wr_data : in  std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wr_strb : in  std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);

    -- Read interface (from bus wrapper)
    rd_en   : in  std_logic;
    rd_addr : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    rd_data : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
    rd_valid: out std_logic;

    -- Register interface to core logic
    regs_out : out t_regs_sw2hw;  -- SW-writable registers (to core)
    regs_in  : in  t_regs_hw2sw   -- HW-writable registers (from core)
  );
end entity {{ entity_name }}_regs;

architecture rtl of {{ entity_name }}_regs is

  -- Internal register storage
  signal regs : t_regs_sw2hw := C_REGS_SW2HW_RESET;

  -- Read data pipeline
  signal rd_data_int  : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal rd_valid_int : std_logic;

  -- Apply write strobe to data
  function apply_wstrb(
    old_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    new_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wstrb    : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0)
  ) return std_logic_vector is
    variable result : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    for i in 0 to (C_DATA_WIDTH/8)-1 loop
      if wstrb(i) = '1' then
        result(i*8+7 downto i*8) := new_data(i*8+7 downto i*8);
      else
        result(i*8+7 downto i*8) := old_data(i*8+7 downto i*8);
      end if;
    end loop;
    return result;
  end function;

begin

  -- Output register values to core
  regs_out <= regs;
  rd_data  <= rd_data_int;
  rd_valid <= rd_valid_int;

  ----------------------------------------------------------------------------
  -- Write Process
  ----------------------------------------------------------------------------
  p_write : process(clk)
    variable v_addr_index : natural;
    variable v_wdata      : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    if rising_edge(clk) then
      if rst = '1' then
        regs <= C_REGS_SW2HW_RESET;
      elsif wr_en = '1' then
        v_addr_index := to_integer(unsigned(wr_addr(C_ADDR_WIDTH-1 downto 2)));

        case v_addr_index is
{% for reg in registers %}
{% if reg.access in ['read-write', 'write-only', 'rw', 'wo', 'read_write', 'write_only'] %}
          when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
            v_wdata := apply_wstrb(to_slv(regs.{{ reg.name | lower }}), wr_data, wr_strb);
            regs.{{ reg.name | lower }} <= to_{{ reg.name | lower }}(v_wdata);
{% endif %}
{% endfor %}
          when others =>
            null;
        end case;
      end if;
    end if;
  end process;

  ----------------------------------------------------------------------------
  -- Read Process
  ----------------------------------------------------------------------------
  p_read : process(clk)
    variable v_addr_index : natural;
  begin
    if rising_edge(clk) then
      rd_valid_int <= '0';

      if rst = '1' then
        rd_data_int  <= (others => '0');
        rd_valid_int <= '0';
      elsif rd_en = '1' then
        v_addr_index := to_integer(unsigned(rd_addr(C_ADDR_WIDTH-1 downto 2)));

        case v_addr_index is
{% for reg in registers %}
{% if reg.access in ['read-only', 'ro', 'read_only'] %}
          when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
            rd_data_int <= to_slv(regs_in.{{ reg.name | lower }});
{% elif reg.access in ['read-write', 'rw', 'read_write'] %}
          when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
            rd_data_int <= to_slv(regs.{{ reg.name | lower }});
{% endif %}
{% endfor %}
          when others =>
            rd_data_int <= (others => '0');
        end case;

        rd_valid_int <= '1';
      end if;
    end if;
  end process;

end architecture rtl;
