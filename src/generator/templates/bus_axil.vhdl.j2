{# VHDL AXI-Lite Bus Wrapper Template #}
{# Generates AXI-Lite slave interface with register decoding #}
--------------------------------------------------------------------------------
-- Entity: {{ entity_name }}_axil
-- Description: AXI-Lite slave interface for register access
-- Generated by ipcore_lib VHDL Generator
--
-- Register Map:
{% for reg in registers %}
--   {{ "0x%04X" | format(loop.index0 * reg_width) }} : {{ reg.name }} ({{ reg.access }})
{% endfor %}
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.{{ entity_name }}_pkg.all;

entity {{ entity_name }}_axil is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

{% if bus_ports %}
    -- AXI-Lite Slave Interface
{% for port in bus_ports %}
    {{ "%-14s"|format(port.name) }} : {{ "%-3s"|format(port.direction) }} {{ port.type }}{{ ";" if not loop.last else "" }}
{% endfor %}
    ;
{% endif %}

    -- Register interface
    regs_out : out t_regs_sw2hw;  -- To core (SW-writable)
    regs_in  : in  t_regs_hw2sw   -- From core (HW-writable)
  );
end entity {{ entity_name }}_axil;

architecture rtl of {{ entity_name }}_axil is

  -- AXI-Lite response constants
  constant C_RESP_OKAY   : std_logic_vector(1 downto 0) := "00";
  constant C_RESP_SLVERR : std_logic_vector(1 downto 0) := "10";

  -- AXI internal signals
  signal axi_awaddr  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
  signal axi_awready : std_logic                                    := '0';
  signal axi_wready  : std_logic                                    := '0';
  signal axi_bresp   : std_logic_vector(1 downto 0)                 := C_RESP_OKAY;
  signal axi_bvalid  : std_logic                                    := '0';
  signal axi_araddr  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
  signal axi_arready : std_logic                                    := '0';
  signal axi_rdata   : std_logic_vector(C_DATA_WIDTH - 1 downto 0) := (others => '0');
  signal axi_rresp   : std_logic_vector(1 downto 0)                 := C_RESP_OKAY;
  signal axi_rvalid  : std_logic                                    := '0';

  -- Register bank interface signals
  signal wr_en     : std_logic;
  signal wr_addr   : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal wr_data   : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal wr_strb   : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
  signal rd_en     : std_logic;
  signal rd_addr   : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal rd_data   : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal rd_valid  : std_logic;

  -- Write transaction tracking using VHDL 2008 records
  type t_write_transaction is record
    aw_en         : std_logic; -- Address write enable flag
    addr_received : std_logic; -- Address has been received
    data_received : std_logic; -- Data has been received
  end record t_write_transaction;

  signal write_txn : t_write_transaction := ('1', '0', '0');

begin

  ----------------------------------------------------------------------------
  -- Register Bank Instantiation
  ----------------------------------------------------------------------------
  u_regs : entity work.{{ entity_name }}_regs
    port map (
      clk      => clk,
      rst      => rst,
      wr_en    => wr_en,
      wr_addr  => wr_addr,
      wr_data  => wr_data,
      wr_strb  => wr_strb,
      rd_en    => rd_en,
      rd_addr  => rd_addr,
      rd_data  => rd_data,
      rd_valid => rd_valid,
      regs_out => regs_out,
      regs_in  => regs_in
    );

  -- Connect internal AXI signals to ports
{% for port in bus_ports %}
{% if port.logical_name == 'AWREADY' %}
  s_axi_awready <= axi_awready;
{% elif port.logical_name == 'WREADY' %}
  s_axi_wready  <= axi_wready;
{% elif port.logical_name == 'BRESP' %}
  s_axi_bresp   <= axi_bresp;
{% elif port.logical_name == 'BVALID' %}
  s_axi_bvalid  <= axi_bvalid;
{% elif port.logical_name == 'ARREADY' %}
  s_axi_arready <= axi_arready;
{% elif port.logical_name == 'RDATA' %}
  s_axi_rdata   <= axi_rdata;
{% elif port.logical_name == 'RRESP' %}
  s_axi_rresp   <= axi_rresp;
{% elif port.logical_name == 'RVALID' %}
  s_axi_rvalid  <= axi_rvalid;
{% endif %}
{% endfor %}

  ----------------------------------------------------------------------------
  -- Write Address Channel
  -- Accept write address when AWVALID is asserted (independent of WVALID)
  ----------------------------------------------------------------------------
  write_addr_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_awready             <= '0';
        write_txn.aw_en         <= '1';
        axi_awaddr              <= (others => '0');
        write_txn.addr_received <= '0';
      else
        if (axi_awready = '0' and s_axi_awvalid = '1' and write_txn.aw_en = '1') then
          -- Ready to accept write address
          axi_awready             <= '1';
          write_txn.aw_en         <= '0';
          axi_awaddr              <= s_axi_awaddr;
          write_txn.addr_received <= '1';
        elsif (axi_bvalid = '1' and s_axi_bready = '1') then
          -- Write response completed, ready for next transaction
          write_txn.aw_en         <= '1';
          write_txn.addr_received <= '0';
          axi_awready             <= '0';
        else
          axi_awready <= '0';
        end if;
      end if;
    end if;
  end process write_addr_proc;

  ----------------------------------------------------------------------------
  -- Write Data Channel
  -- Accept write data when WVALID is asserted (independent of AWVALID)
  ----------------------------------------------------------------------------
  write_data_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_wready              <= '0';
        write_txn.data_received <= '0';
      else
        if (axi_wready = '0' and s_axi_wvalid = '1') then
          -- Ready to accept write data
          axi_wready              <= '1';
          write_txn.data_received <= '1';
        elsif (axi_bvalid = '1' and s_axi_bready = '1') then
          -- Write response completed, ready for next transaction
          write_txn.data_received <= '0';
          axi_wready              <= '0';
        else
          axi_wready <= '0';
        end if;
      end if;
    end if;
  end process write_data_proc;

  ----------------------------------------------------------------------------
  -- Register Write Control
  -- Generate write enable to register bank when both address and data received
  ----------------------------------------------------------------------------
  wr_en   <= write_txn.addr_received and write_txn.data_received;
  wr_addr <= axi_awaddr;
  wr_data <= s_axi_wdata;
  wr_strb <= s_axi_wstrb;

  ----------------------------------------------------------------------------
  -- Write Response Logic
  ----------------------------------------------------------------------------
  write_response_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_bvalid <= '0';
        axi_bresp  <= C_RESP_OKAY;
      else
        if (write_txn.addr_received = '1' and write_txn.data_received = '1' and axi_bvalid = '0') then
          -- Both address and data received, assert write response
          axi_bvalid <= '1';
          axi_bresp  <= C_RESP_OKAY;
        elsif (s_axi_bready = '1' and axi_bvalid = '1') then
          -- Write response accepted by master
          axi_bvalid <= '0';
        end if;
      end if;
    end if;
  end process write_response_proc;

  ----------------------------------------------------------------------------
  -- Read Address Channel
  ----------------------------------------------------------------------------
  read_addr_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_arready <= '0';
        axi_araddr  <= (others => '0');
      else
        if (axi_arready = '0' and s_axi_arvalid = '1') then
          axi_arready <= '1';
          axi_araddr  <= s_axi_araddr;
        else
          axi_arready <= '0';
        end if;
      end if;
    end if;
  end process read_addr_proc;

  ----------------------------------------------------------------------------
  -- Register Read Control
  -- Trigger read from register bank when address is accepted
  ----------------------------------------------------------------------------
  rd_en   <= axi_arready and s_axi_arvalid and not axi_rvalid;
  rd_addr <= axi_araddr;

  ----------------------------------------------------------------------------
  -- Read Valid Generation
  -- Assert RVALID when register bank provides valid read data
  ----------------------------------------------------------------------------
  read_valid_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_rvalid <= '0';
        axi_rresp  <= C_RESP_OKAY;
        axi_rdata  <= (others => '0');
      else
        if rd_valid = '1' then
          -- Register bank has valid data
          axi_rvalid <= '1';
          axi_rresp  <= C_RESP_OKAY;
          axi_rdata  <= rd_data;
        elsif (axi_rvalid = '1' and s_axi_rready = '1') then
          -- Master accepted read data
          axi_rvalid <= '0';
        end if;
      end if;
    end if;
  end process read_valid_proc;

end architecture rtl;
