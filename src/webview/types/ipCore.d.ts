/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Schema version (e.g., 'my-ip-schema/v2.3')
 */
export type Apiversion = string;
/**
 * Vendor identifier (e.g., 'my-company.com')
 */
export type Vendor = string;
/**
 * Library name (e.g., 'processing')
 */
export type Library = string;
/**
 * IP core name (e.g., 'my_timer_core')
 */
export type Name = string;
/**
 * Version string (e.g., '1.2.0')
 */
export type Version = string;
/**
 * IP core description
 */
export type Description = string;
/**
 * Physical port name (HDL)
 */
export type Name1 = string;
/**
 * Standard logical name for association
 */
export type Logicalname = string;
/**
 * Port direction (typically 'in')
 */
export type PortDirection = "in" | "out" | "inout";
/**
 * Port width in bits or parameter name
 */
export type Width = number | string;
/**
 * VHDL type (e.g. std_logic, std_logic_vector)
 */
export type Type = string;
/**
 * Port description
 */
export type Description1 = string;
/**
 * Clock frequency (e.g., '100MHz')
 */
export type Frequency = string | null;
/**
 * Clock definitions
 */
export type Clocks = Clock[];
/**
 * Physical port name (HDL)
 */
export type Name2 = string;
/**
 * Standard logical name for association
 */
export type Logicalname1 = string;
/**
 * Port direction (typically 'in')
 */
export type PortDirection1 = "in" | "out" | "inout";
/**
 * Port width in bits or parameter name
 */
export type Width1 = number | string;
/**
 * VHDL type (e.g. std_logic, std_logic_vector)
 */
export type Type1 = string;
/**
 * Port description
 */
export type Description2 = string;
/**
 * Reset polarity (activeHigh or activeLow)
 */
export type Polarity = "activeHigh" | "activeLow";
/**
 * Reset definitions
 */
export type Resets = Reset[];
/**
 * Physical port name (HDL)
 */
export type Name3 = string;
/**
 * Standard logical name for association
 */
export type Logicalname2 = string;
/**
 * Port direction
 */
export type PortDirection2 = "in" | "out" | "inout";
/**
 * Port width in bits or parameter name
 */
export type Width2 = number | string;
/**
 * VHDL type (e.g. std_logic, std_logic_vector)
 */
export type Type2 = string;
/**
 * Port description
 */
export type Description3 = string;
/**
 * Data/control ports
 */
export type Ports = Port[];
/**
 * Logical interface name
 */
export type Name4 = string;
/**
 * Bus type from library (e.g., 'AXI4L', 'AXIS')
 */
export type Type3 = string;
/**
 * Interface mode: 'master' or 'slave'
 */
export type BusInterfaceMode = "master" | "slave" | "source" | "sink";
/**
 * Prefix for physical port names (e.g., 's_axi_')
 */
export type Physicalprefix = string;
/**
 * Logical clock name this interface uses
 */
export type Associatedclock = string | null;
/**
 * Logical reset name this interface uses
 */
export type Associatedreset = string | null;
/**
 * Memory map name for register access
 */
export type Memorymapref = string | null;
/**
 * List of optional ports to include
 */
export type Useoptionalports = string[];
/**
 * Number of instances
 */
export type Count = number;
/**
 * Starting index
 */
export type Indexstart = number;
/**
 * Naming pattern with {index} placeholder (e.g., 'M_AXIS_CH{index}_EVENTS')
 */
export type Namingpattern = string;
/**
 * Physical prefix pattern with {index} placeholder
 */
export type Physicalprefixpattern = string;
/**
 * Interface description
 */
export type Description4 = string;
/**
 * Bus interface definitions
 */
export type Businterfaces = BusInterface[];
/**
 * Memory map name
 */
export type Name5 = string;
/**
 * Memory map description
 */
export type Description5 = string;
/**
 * Block name
 */
export type Name6 = string;
/**
 * Block starting address
 */
export type Baseaddress = number | null;
/**
 * Block size (bytes or '4K', '1M', etc.)
 */
export type Range = number | string | null;
/**
 * Block usage type
 */
export type BlockUsage = "register" | "memory" | "reserved";
/**
 * Default access
 */
export type AccessType = "read-only" | "write-only" | "read-write" | "write-1-to-clear" | "read-write-1-to-clear";
/**
 * Block description
 */
export type Description6 = string;
/**
 * Default register width
 */
export type Defaultregwidth = number;
/**
 * Register name
 */
export type Name7 = string;
/**
 * Offset from address block base
 */
export type Offset = number | null;
/**
 * Register width in bits
 */
export type Size = number;
/**
 * Default access type
 */
export type AccessType1 = "read-only" | "write-only" | "read-write" | "write-1-to-clear" | "read-write-1-to-clear";
/**
 * Reset value for entire register
 */
export type Resetvalue = number | null;
/**
 * Register description
 */
export type Description7 = string;
/**
 * Bit field name
 */
export type Name8 = string;
/**
 * Starting bit position (LSB = 0)
 */
export type Offset1 = number | null;
/**
 * Number of bits
 */
export type Width3 = number | null;
/**
 * Bit range string e.g. [7:0]
 */
export type Bits = string | null;
/**
 * Access type
 */
export type AccessType2 = "read-only" | "write-only" | "read-write" | "write-1-to-clear" | "read-write-1-to-clear";
/**
 * Reset/default value
 */
export type Resetvalue1 = number | null;
/**
 * Field description
 */
export type Description8 = string;
/**
 * Enumeration mapping {value: name}
 */
export type Enumeratedvalues = {
  [k: string]: string;
} | null;
/**
 * Bit fields
 */
export type Fields = BitFieldDef[];
/**
 * Child registers (for groups)
 */
export type Registers1 = RegisterDef[];
/**
 * Array replication count
 */
export type Count1 = number | null;
/**
 * Array replication stride
 */
export type Stride = number | null;
/**
 * Registers in block
 */
export type Registers = RegisterDef[];
/**
 * Address blocks
 */
export type Addressblocks = AddressBlock[];
/**
 * Memory maps
 */
export type Memorymaps = MemoryMap[];
/**
 * File set name
 */
export type Name9 = string;
/**
 * File set description
 */
export type Description9 = string;
/**
 * Relative or absolute file path
 */
export type Path = string;
/**
 * File type
 */
export type FileType =
  | "vhdl"
  | "verilog"
  | "systemverilog"
  | "xdc"
  | "sdc"
  | "ucf"
  | "cHeader"
  | "cSource"
  | "cppHeader"
  | "cppSource"
  | "python"
  | "makefile"
  | "pdf"
  | "markdown"
  | "text"
  | "tcl"
  | "yaml"
  | "json"
  | "xml"
  | "unknown";
/**
 * File description
 */
export type Description10 = string;
/**
 * Whether file is an include file
 */
export type Isincludefile = boolean;
/**
 * Logical name (e.g., library name for VHDL)
 */
export type Logicalname3 = string;
/**
 * Files in this set
 */
export type Files = File[];
/**
 * File sets
 */
export type Filesets = FileSet[];
/**
 * Parameter name
 */
export type Name10 = string;
/**
 * Data type
 */
export type ParameterType = "integer" | "natural" | "positive" | "real" | "boolean" | "string";
/**
 * Parameter description
 */
export type Description11 = string;
/**
 * Generics/parameters
 */
export type Parameters = Parameter[];
/**
 * Path to bus definitions library
 */
export type Usebuslibrary = string | null;

/**
 * Complete IP core definition - the single source of truth.
 *
 * This is the canonical data model that all parsers produce and
 * all generators consume. It includes:
 * - Metadata (VLNV, description)
 * - Interface definitions (clocks, resets, ports, buses)
 * - Memory maps (registers, bit fields)
 * - Files (HDL sources, constraints, documentation)
 * - Parameters/generics
 */
export interface IpCore {
  apiVersion: Apiversion;
  vlnv: VLNV;
  description?: Description;
  clocks?: Clocks;
  resets?: Resets;
  ports?: Ports;
  busInterfaces?: Businterfaces;
  memoryMaps?: Memorymaps;
  fileSets?: Filesets;
  parameters?: Parameters;
  useBusLibrary?: Usebuslibrary;
}
/**
 * Unique identifier
 */
export interface VLNV {
  vendor: Vendor;
  library: Library;
  name: Name;
  version: Version;
  [k: string]: unknown;
}
/**
 * Clock definition for an IP core.
 *
 * Defines both logical (internal) and physical (port) names for clock signals.
 * Inherits from Port, typically with width=1.
 */
export interface Clock {
  name: Name1;
  logicalName?: Logicalname;
  direction?: PortDirection;
  width?: Width;
  type?: Type;
  description?: Description1;
  frequency?: Frequency;
}
/**
 * Reset definition for an IP core.
 *
 * Defines both logical (internal) and physical (port) names for reset signals,
 * including polarity information.
 * Inherits from Port, typically with width=1.
 */
export interface Reset {
  name: Name2;
  logicalName?: Logicalname1;
  direction?: PortDirection1;
  width?: Width1;
  type?: Type1;
  description?: Description2;
  polarity?: Polarity;
}
/**
 * Generic port definition for IP cores.
 *
 * Used for data and control ports that are not part of clock, reset, or bus interfaces.
 */
export interface Port {
  name: Name3;
  logicalName?: Logicalname2;
  direction: PortDirection2;
  width?: Width2;
  type?: Type2;
  description?: Description3;
}
/**
 * Bus interface definition for an IP core.
 *
 * Represents a standardized bus connection (AXI, Avalon, etc.) with
 * optional width overrides, clock/reset associations, and array support.
 */
export interface BusInterface {
  name: Name4;
  type: Type3;
  mode: BusInterfaceMode;
  physicalPrefix: Physicalprefix;
  associatedClock?: Associatedclock;
  associatedReset?: Associatedreset;
  memoryMapRef?: Memorymapref;
  memory_map_ref?: Memorymapref;
  useOptionalPorts?: Useoptionalports;
  portWidthOverrides?: Portwidthoverrides;
  /**
   * Array configuration for multiple instances
   */
  array?: ArrayConfig | null;
  description?: Description4;
}
/**
 * Port width overrides {port_name: width}
 */
export interface Portwidthoverrides {
  [k: string]: number;
}
/**
 * Configuration for array of bus interfaces.
 *
 * Enables creation of multiple interface instances (e.g., 4 AXI Stream channels).
 */
export interface ArrayConfig {
  count: Count;
  indexStart?: Indexstart;
  namingPattern: Namingpattern;
  physicalPrefixPattern: Physicalprefixpattern;
}
/**
 * Complete memory map for an IP core (Pydantic model).
 *
 * Organizes registers into address blocks with validation.
 */
export interface MemoryMap {
  name: Name5;
  description?: Description5;
  address_blocks?: Addressblocks;
  addressBlocks?: Addressblocks;
}
/**
 * Contiguous address block within a memory map (Pydantic model).
 *
 * Can contain registers, memory, or reserved space.
 */
export interface AddressBlock {
  name: Name6;
  base_address?: number;
  baseAddress?: Baseaddress;
  range?: Range;
  usage?: BlockUsage;
  access?: AccessType;
  description?: Description6;
  defaultRegWidth?: Defaultregwidth;
  registers?: Registers;
  [k: string]: unknown;
}
/**
 * Register definition within a memory map (Pydantic model for YAML parsing).
 *
 * Represents a memory-mapped register with bit fields.
 */
export interface RegisterDef {
  name: Name7;
  offset?: Offset;
  size?: Size;
  access?: AccessType1;
  resetValue?: Resetvalue;
  description?: Description7;
  fields?: Fields;
  registers?: Registers1;
  count?: Count1;
  stride?: Stride;
  [k: string]: unknown;
}
/**
 * Bit field definition within a register (Pydantic model for YAML parsing).
 *
 * Represents a named range of bits with specific access semantics.
 */
export interface BitFieldDef {
  name: Name8;
  offset?: Offset1;
  width?: Width3;
  bits?: Bits;
  access?: AccessType2;
  resetValue?: Resetvalue1;
  description?: Description8;
  enumeratedValues?: Enumeratedvalues;
  [k: string]: unknown;
}
/**
 * Named collection of files for an IP core.
 *
 * Groups related files together (e.g., RTL sources, C API, documentation).
 */
export interface FileSet {
  name: Name9;
  description?: Description9;
  files?: Files;
}
/**
 * File reference within a file set.
 *
 * Represents a file that is part of the IP core (source, constraint, doc, etc.).
 */
export interface File {
  path: Path;
  type: FileType;
  description?: Description10;
  isIncludeFile?: Isincludefile;
  logicalName?: Logicalname3;
}
/**
 * Generic parameter/generic definition for IP cores.
 *
 * Used for VHDL generics, Verilog parameters, or component configuration.
 */
export interface Parameter {
  name: Name10;
  value: Value;
  dataType?: ParameterType;
  description?: Description11;
}
/**
 * Default value
 */
export interface Value {
  [k: string]: unknown;
}
